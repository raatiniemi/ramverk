<?php
/*
Controller
- Retrieve the request information.
-- Pass the url (routing pattern) and the parsed routing configuration to the routing class.
-- Retrieve the module and action name from the routing.
--- If none is found initialize the 404.
-- Based on the request method the action method name will be modified (read/write).
--- Check if the action has the method, fallback to 'execute'.
-- Create the action, and execute the method.
--- The method return one part of the view name, e.g. in the login case, 'form'
    for input username/password and 'success' for an actual login.
-- Assemble the name of the view class, the first part should be the same as the
   action, and the second part is the value returned from the action method. E.g. if
   the action is named Login and return 'form', then the view class should be LoginForm.
--- Based on the header content type the response (view method) should be different.
    E.g. if the content type is json the method should be executeJson.



$routing = new routing();
$request = new request();
$response = new response();

$controller = new Controller($context, $routing, $request, $response);

dispatch() {
	$routing->parseRoute($this->request->getUri);
}



TODO: Figure out a way to loosen the coupling between controller and request, reponse, and routing.
The controller needs to be testable, hence the mentioned objects needs to
be injected to the controller and not instansiated within the controller.

The action and view (and later model) will most likley have to be instansiated
within the controller, since that is basically the purpose of the controller dispatch.

TODO: Implement support for request and response data.
The request data will be headers, post and get data, json data, etc. Based on the
request data different arguments should be sent to the action. The action in turn
will talk to the model and retrieve the response data.

The reponse will need access to the request data aswell, since the accept headers
will be located there and those values will determind which content type to send
back to the user.


Array
(
	[directory.core] => /var/www/ramverk/src
	[directory.application] => /var/www/ramverk/trunk
	[profile] => development
	[context] => web
	[exception.template] => %directory.core.template%/exception/plaintext.php
	[directory.core.config] => %directory.core%/config
	[directory.core.library] => %directory.core%/library
	[directory.core.template] => %directory.core%/template
	[directory.application.cache] => %directory.application%/cache
	[directory.application.config] => %directory.application%/config
	[directory.application.library] => %directory.application%/library
	[directory.application.module] => %directory.application%/module
	[directory.application.template] => %directory.application%/template
)





// Define the context based request, routing, and response classes with their namespaces.
$class['rq'] = "{$namespace['base']}\\Request\\{$context}";
$class['rd'] = "{$namespace['base']}\\Request\\{$context}\\Data";
$class['routing'] = "{$namespace['base']}\\Routing\\{$context}";
$class['response'] = "{$namespace['base']}\\Response\\{$context}";

// Verify that each of the context based classes exists.
foreach($class as $key => $value) {
	if(!class_exists($value)) {
		throw new \Exception("Context based '{$key}'-class do not exists");
	}
}
$reflection['rd'] = new \ReflectionClass($class['rd']);
$rd = $reflection['rd']->newInstance();

// TODO: Send arguments to request constructor?
$reflection['rq'] = new \ReflectionClass($class['rq']);
$rq = $reflection['rq']->newInstanceArgs(array($core->getContext(), $rd));

// Retrieve the routing configuration.
$routes = $factory->callHandler('Routing', '%directory.application.config%/routing.xml');

$reflection['routing'] = new \ReflectionClass($class['routing']);
$routing = $reflection['routing']->newInstanceArgs(array($rq, $routes));
$routing->parse();

if(!$routing->hasRoute()) {
	// TODO: Initialize the module and action with the 404.
	// This way we can send the 404 page with the requested content type,
	// e.g. pages requested with application/json in the accept header will
	// receive the the 404 with application/json.
	throw new \Exception('Page not found');
}

$config->set('directory.module', "%directory.application.module%/{$routing->getModule()}");
if(!is_dir($config->expandDirectives('%directory.module%'))) {
	throw new \Exception('Module do not exists');
}

// TODO: Better handling.
$config->set('directory.module.config', '%directory.module%/config');
$module = $config->expandDirectives('%directory.module.config%/module.xml');
if(is_readable($module)) {
	// TODO: Prevent overrides and configuration directive collisions.
	$config->import($factory->callHandler('Module', $module));
}

// ---- Handle Action

$name['action'] = $class['action'] = $routing->getAction();
if($config->has('namespace')) {
	// TODO: Add support for custom action namespace.
	$class['action'] = sprintf('%s\\Action\\%s', $config->get('namespace'), $class['action']);
}

// TODO: Send arguments to action constructor?
$reflection['action'] = new \ReflectionClass($class['action']);
$action = $reflection['action']->newInstance();

// TODO: Is the reflection really necessary?
$method['action'] = $routing->getActionMethod($reflection['action']);

// TODO: Migrate the request data handling.
$arguments['action'] = array();
if($method['action'] === 'executeWrite') {
	$validate = require 'validate.php';

	if(array_key_exists($routing->getModule(), $validate)) {
		$validate['module'] = $validate[$routing->getModule()];
		if(is_array($validate['module']) && array_key_exists($routing->getAction(), $validate['module'])) {
			$validate['action'] = $validate['module'][$routing->getAction()];

			$data = $rq->getRequestRawData();
			if(!empty($data)) {
				foreach($data as $index => $value) {
					// If the request data index do not exists within the validation
					// for the defined module/action then it should be removed from
					// the request data.
					//
					// The same goes for values that do not match the supplied regex.
					if(!array_key_exists($index, $validate['action'])) {
						unset($data[$index]);
					} else {
						$regex = isset($validate['action'][$index]['regex']) ? $validate['action'][$index]['regex'] : NULL;
						if(empty($regex) || !preg_match($regex, $value)) {
							unset($data[$index]);
						}
					}
				}

				// We can assign the remaining data to the action arguments.
				$arguments['action'] = $data;
			}
		}
	}
}

// Retrieve the view name.
$name['view'] = call_user_func_array(array($action, $method['action']), $arguments['action']);
if(!isset($name['view']) || !is_string($name['view'])) {
	// The action method have to return a name.
	// TODO: Write exception message.
	// TODO: Better specify the exception object.
	throw new \Exception('');
}

// ---- Handle View

// TODO: Handle headers within the reponse.
exit;

$reflection['response'] = new \ReflectionClass($class['response']);
$response = $reflection['response']->newInstance();

// TODO: Accept will only be availabe within the Web context.
$accepts = $response->getAccept();

$name['view'] = $class['view'] = sprintf('%s%s', $name['action'], ucfirst(strtolower($name['view'])));
if($config->has('namespace')) {
	// TODO: Add support for custom view namespace.
	$class['view'] = sprintf('%s\\View\\%s', $config->get('namespace'), $class['view']);
}
$reflection['view'] = new \ReflectionClass($class['view']);
foreach($accepts as $accept) {
	$accept = strtolower($accept);

	switch($accept) {
		case 'application/json':
			$type = 'json';
			break;
		case 'text/html':
		default:
			$type = 'html';
			break;
	}

	// TODO: Better handling for headers, add support for redirections etc.
	$method['view'] = sprintf('execute%s', ucfirst(strtolower($type)));
	if($reflection['view']->hasMethod($method['view'])) {
		// Send the content-type header back with the correct content type.
		header("Content-type: {$accept}");
		break;
	}
}

// If no method have been found for the view, use the default one.
if(!isset($method['view'])) {
	$method['view'] = 'execute';
}

// TODO: Send arguments to view constructor?
$view = $reflection['view']->newInstance();
echo call_user_func_array(array($view, $method['view']), array());



















































			$factory = $this->getConfigurationHandlerFactory();
			$routes = $factory->callHandler('Routing', '%directory.application.config%/routing.xml');

			// TODO: Within the Routing class include these methods,
			// getModule/getAction with ucfirst and strtolower convertion.
			// method should be handled within the controller dispatch.
			$uri = isset($_GET['uri']) ? $_GET['uri'] : '';
			foreach($routes as $route) {
				if(preg_match("#{$route['pattern']}#", $uri)) {
					$this->_route = $route;
					break;
				}
			}

			// If no route have been found.
			// TODO: check against the routing class, hasRoute() which should return a boolean.
			if($this->_route === NULL) {
				throw new Exception('#404 - No route have been found.');
			}

			// Retrieve the absolute path for the module directory.
			$config = array();
			$config['directory'] = $this->getConfig()->expandDirectives('%directory.application.module%');
			$config['directory'] = sprintf('%s/%s', $config['directory'], ucfirst($this->_route['module']));

			// Verify that the module directory do exists.
			if(!is_dir($config['directory'])) {
				// TODO: Write exception message.
				// TODO: Better specify the exception object.
				throw new Exception('');
			}

			// Check if the module configuration exists. If it does, then we
			// need to retrieve the configuration data.
			$module = sprintf('%s/config/module.xml', $config['directory']);
			if(file_exists($module)) {
				$config = array_merge($config, $factory->callHandler('Module', $module));
			}

			// Check if the module autoload configuration exists. If it does,
			// then we need to register the controllers autoloader.
			$autoload = sprintf('%s/config/autoload.xml', $config['directory']);
			if(file_exists($autoload)) {
				// Register the controllers autoloader.
				$this->setAutoloadFile($autoload);
				spl_autoload_register(array($this, 'autoload'), TRUE, TRUE);
			}

			$method = strtolower($_SERVER['REQUEST_METHOD']) === 'post' ? 'write' : 'read';
			$action['method'] = sprintf('execute%s', ucfirst($method));

			// If we have a module namespace available, we have to prepend it to
			// the action class, otherwise we won't find the class.
			$action['name'] = $action['class'] = ucfirst(strtolower($route['action']));
			if(isset($config['namespace'])) {
				$action['class'] = sprintf('%s\\Action\\%s', $config['namespace'], $action['class']);
			}

			// Checking that the action class have the specified method, otherwise
			// fallback to the default execute method.
			$action['reflection'] = new \ReflectionClass($action['class']);
			if(!$action['reflection']->hasMethod($action['method'])) {
				$action['method'] = 'execute';
			}

			// Instansiate the action class.
			// TODO: Do we need to pass any arguments to the action constructor?
			$action['instance'] = $action['reflection']->newInstance();

			// Execute the action method, and retrieve the view name.
			$view['name'] = call_user_func_array(array($action['instance'], $action['method']), array());
			if(!isset($view['name']) || !is_string($view['name'])) {
				// The action method have to return a name.
				// TODO: Write exception message.
				// TODO: Better specify the exception object.
				throw new Exception('');
			}

			// If we have a module namespace available, we have to prepend it to
			// the view class, otherwise we won't find the class.
			$view['name'] = $view['class'] = sprintf('%s%s', $action['name'], ucfirst(strtolower($view['name'])));
			if(isset($config['namespace'])) {
				$view['class'] = sprintf('%s\\View\\%s', $config['namespace'], $view['class']);
			}

			// The entire initialization of the view will be rewritten when I
			// figure out a better way of doing it.
			//
			// Retrieve the content type from the header.
			$headers = array_change_key_case(getallheaders());
			if(isset($headers['content-type'])) {
				$contentType = strtolower($headers['content-type']);

				switch($contentType) {
					case 'application/json':
						$type = 'json';
						break;
					case 'text/html':
					default:
						$type = 'html';
						break;
				}
			} else {
				$type = 'html';
			}
			$view['method'] = sprintf('execute%s', ucfirst(strtolower($type)));

			// Checking that the view class have the specified method, otherwise
			// fallback to the default execute method.
			$view['reflection'] = new \ReflectionClass($view['class']);
			if(!$view['reflection']->hasMethod($view['method'])) {
				$view['method'] = 'execute';
			}

			// Instansiate the view, and execute the method.
			$view['instance'] = $view['reflection']->newInstance();
			echo call_user_func_array(array($view['instance'], $view['method']), array());


*/