Controller
- Retrieve the request information.
-- Pass the url (routing pattern) and the parsed routing configuration to the routing class.
-- Retrieve the module and action name from the routing.
--- If none is found initialize the 404.
-- Based on the request method the action method name will be modified (read/write).
--- Check if the action has the method, fallback to 'execute'.
-- Create the action, and execute the method.
--- The method return one part of the view name, e.g. in the login case, 'form'
    for input username/password and 'success' for an actual login.
-- Assemble the name of the view class, the first part should be the same as the
   action, and the second part is the value returned from the action method. E.g. if
   the action is named Login and return 'form', then the view class should be LoginForm.
--- Based on the header content type the response (view method) should be different.
    E.g. if the content type is json the method should be executeJson.





$routing = new routing();
$request = new request();
$response = new response();

$controller = new Controller($context, $routing, $request, $response);

dispatch() {
	$routing->parseRoute($this->request->getUri);
}






/*


		// Define the context based request, routing, and response classes with their namespaces.
		$class['rq'] = "{$namespace['base']}\\Request\\{$context}";
		$class['rd'] = "{$namespace['base']}\\Request\\{$context}\\Data";
		$class['routing'] = "{$namespace['base']}\\Routing\\{$context}";
		$class['response'] = "{$namespace['base']}\\Response\\{$context}";

		// Verify that each of the context based classes exists.
		foreach($class as $key => $value) {
			if(!class_exists($value)) {
				throw new \Exception("Context based '{$key}'-class do not exists");
			}
		}
		$reflection['rd'] = new \ReflectionClass($class['rd']);
		$rd = $reflection['rd']->newInstance();

		// TODO: Send arguments to request constructor?
		$reflection['rq'] = new \ReflectionClass($class['rq']);
		$rq = $reflection['rq']->newInstanceArgs(array($core->getContext(), $rd));

		// Retrieve the routing configuration.
		$routes = $factory->callHandler('Routing', '%directory.application.config%/routing.xml');

		$reflection['routing'] = new \ReflectionClass($class['routing']);
		$routing = $reflection['routing']->newInstanceArgs(array($rq, $routes));
		$routing->parse();

		if(!$routing->hasRoute()) {
			// TODO: Initialize the module and action with the 404.
			// This way we can send the 404 page with the requested content type,
			// e.g. pages requested with application/json in the accept header will
			// receive the the 404 with application/json.
			throw new \Exception('Page not found');
		}

		$config->set('directory.module', "%directory.application.module%/{$routing->getModule()}");
		if(!is_dir($config->expandDirectives('%directory.module%'))) {
			throw new \Exception('Module do not exists');
		}

		// TODO: Better handling.
		$config->set('directory.module.config', '%directory.module%/config');
		$module = $config->expandDirectives('%directory.module.config%/module.xml');
		if(is_readable($module)) {
			// TODO: Prevent overrides and configuration directive collisions.
			$config->import($factory->callHandler('Module', $module));
		}

		// ---- Handle Action

		$name['action'] = $class['action'] = $routing->getAction();
		if($config->has('namespace')) {
			// TODO: Add support for custom action namespace.
			$class['action'] = sprintf('%s\\Action\\%s', $config->get('namespace'), $class['action']);
		}

		// TODO: Send arguments to action constructor?
		$reflection['action'] = new \ReflectionClass($class['action']);
		$action = $reflection['action']->newInstance();

		// TODO: Is the reflection really necessary?
		$method['action'] = $routing->getActionMethod($reflection['action']);

		// TODO: Migrate the request data handling.
		$arguments['action'] = array();
		if($method['action'] === 'executeWrite') {
			$validate = require 'validate.php';

			if(array_key_exists($routing->getModule(), $validate)) {
				$validate['module'] = $validate[$routing->getModule()];
				if(is_array($validate['module']) && array_key_exists($routing->getAction(), $validate['module'])) {
					$validate['action'] = $validate['module'][$routing->getAction()];

					$data = $rq->getRequestRawData();
					if(!empty($data)) {
						foreach($data as $index => $value) {
							// If the request data index do not exists within the validation
							// for the defined module/action then it should be removed from
							// the request data.
							//
							// The same goes for values that do not match the supplied regex.
							if(!array_key_exists($index, $validate['action'])) {
								unset($data[$index]);
							} else {
								$regex = isset($validate['action'][$index]['regex']) ? $validate['action'][$index]['regex'] : NULL;
								if(empty($regex) || !preg_match($regex, $value)) {
									unset($data[$index]);
								}
							}
						}

						// We can assign the remaining data to the action arguments.
						$arguments['action'] = $data;
					}
				}
			}
		}

		// Retrieve the view name.
		$name['view'] = call_user_func_array(array($action, $method['action']), $arguments['action']);
		if(!isset($name['view']) || !is_string($name['view'])) {
			// The action method have to return a name.
			// TODO: Write exception message.
			// TODO: Better specify the exception object.
			throw new \Exception('');
		}

		// ---- Handle View

		// TODO: Handle headers within the reponse.
		exit;

		$reflection['response'] = new \ReflectionClass($class['response']);
		$response = $reflection['response']->newInstance();

		// TODO: Accept will only be availabe within the Web context.
		$accepts = $response->getAccept();

		$name['view'] = $class['view'] = sprintf('%s%s', $name['action'], ucfirst(strtolower($name['view'])));
		if($config->has('namespace')) {
			// TODO: Add support for custom view namespace.
			$class['view'] = sprintf('%s\\View\\%s', $config->get('namespace'), $class['view']);
		}
		$reflection['view'] = new \ReflectionClass($class['view']);
		foreach($accepts as $accept) {
			$accept = strtolower($accept);

			switch($accept) {
				case 'application/json':
					$type = 'json';
					break;
				case 'text/html':
				default:
					$type = 'html';
					break;
			}

			// TODO: Better handling for headers, add support for redirections etc.
			$method['view'] = sprintf('execute%s', ucfirst(strtolower($type)));
			if($reflection['view']->hasMethod($method['view'])) {
				// Send the content-type header back with the correct content type.
				header("Content-type: {$accept}");
				break;
			}
		}

		// If no method have been found for the view, use the default one.
		if(!isset($method['view'])) {
			$method['view'] = 'execute';
		}

		// TODO: Send arguments to view constructor?
		$view = $reflection['view']->newInstance();
		echo call_user_func_array(array($view, $method['view']), array());
 */